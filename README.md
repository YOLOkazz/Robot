#РОБОТ НА КЛЕТЧАТОМ ПОЛЕ СО СТОРОНАМИ ГОРИЗОНТА

Данное ПО предназначено для поддержки начального курса программирования для студентов-первокурсников, целью которого является научить писать хорошо структурированный программный код, остновываясь на технологии проектирования сверху вниз, и включая использование идей обобщенного программирования. Предлагаемое ПО помогает легко формулировать учебные задачи, сложность которых можно варьировать в достаточно широких пределах, и на которых можно научить всему заявленному, по крайней мере в первом приближении.

Важно также, что для достижения этой цели язык программирования Julia с его ясным и удобным синтаксисом, развитой системой типов и поддержкой основных современных парадигм программирования, а также с его интерактивными возможностями является весьма подходящим (о рекомендуемых источниках информации о новом, набирающем популяпность, языке программирования Julia см. ниже). 

Файл robot.jl содержит определение модуля HorizonSideRobot ("робот на клетчатом поле со сторонами горизонта"), включающего в себя определения следующих экспортируемых типов данных.

 1. Перечисление (enum) HorizonSide Nord=0 West=1 Sud=2 Ost=3, определяющее         
    обозначения сторон горизонта (Cевер, Запад, Юг, Восток, соответственно)

 2. Тип Robot с экспортируемыми функциями: 
        Robot(...) - имеются разные варианты вызова конструктора (см. ниже)
        move!(::Robot, ::HorizonSide)::Nothing
        isborder(::Robot,::HorizonSide)::Bool
        putmarker!(::Robot)::Nothing
        ismarker(::Robot)::Bool
        temperature(::Robot)::Int
        show(::Robor; edit=false | true)::Nothing
        save(::Robot,::AbstractString)
    предназначенный для создания объектов ("роботов на клетчатом поле со сторонами горизонта"). Такой объект (робот) позволяет имитировать программное управление роботом, движущимся по клетчатому полю с заданной обстановкой и выполняющим на нем те или иные действия.    

Обстановка на поле определяется наличием или отсутствием ограничивающей поле прямоугольной рамки (поле может быть и неограниченным), наличием или отсутствием внутренних (межклеточных) перегородок, наличием или отсутствием маркеров на клетках поля, положением робота на поле.

##Подготовка к работе с модулем

1. Работа данного модуля требует, чтобы на комьютере был установлен интерпретатор Python 3 c библиотекой matplotlib. Для этого проще всего воспользоваться дистрибутивом Anaconda, и тогда все это будет гарантированно установлено, инструкцию по установке см., например, здесь https://pythonru.com/baza-znanij/kak-ustanovit-anaconda-na-windows. Julia желательно установить уже после установки Anaconda (тогда все необходимые действи по интеграции установщик Julia выполнит автоматически). Скачать ее надо с сайта разработчиков https://julialang.org/downloads,если потребуется, то инструкцию по установке см, например, здесь https://techytok.com/julia-vscode/ (при необходимости можно воспользоваться goole-переводчиком).

2. Желательно также установить редактор про,граммного кода VS Code с расширением Julia
(по-видимому, на сегодняшний день это наиболее удобный выриант программирования на языке Julia, по крайней мере для начинающих). Также надо будет позаботиться, чтобы путь к папке с julia.exe был известен VS Code, инструкцию можно найти, например, здесь https://techytok.com/julia-vscode/ (при необходимости можно воспользоваться goole-переводчиком).

3. После этого уже из REPL Julia необходимо будет скачать с GitHab пакет PyPlot.jl.   

ПОЯСНЕНИЕ для новичков в Julia. Делается это с помощью встроенного пакетного менеджера очень просто. Сначала надо из стандартного режима REPL перейти в режим пакетного менеджера, набрав 
julia>]+<Enter>

После чего выполнить скачивание: pkg>add PyPlot.jl+<Enter>
Процесс скачивания займет некоторое время. 
После его завершения следует вернуться в стандартный режим REPL нажатием клавиши <Backspace> ("забой") 

4. Файл robot.jl из данного репозитория следует скачать и скопировать (в разорхивированном виде) в заранее созданную на компьютере специальную рабочую папку, которую следует сделать текущей (просто открыв ее в VS Code), и в которой впоследствии следует сохранять все свои файлы и папки с программным кодом и другие файлы (например файлы с обстановкой на поле). 

5. Теперь для начала работы с "роботом" требуется выполнить включение содержимого файла "robot.jl" в область REPL (интерактивное коммандное окно Julia)
> include("robot.jl")

После этого включения имена HorizonSide, Nord, West, Sud, Ost, Robot, move!, isborder, putmarker!, ismarker, temperature, show, save, а так же - sitedit, sitcreate окажутся доступными в соответствующем пространстве имен. 
В результате, в частности, станет возможным получить более детальную информацию о каждом из них с помощью встроенной системы помощи (help). 

ПОЯСНЕНИЕ для новичков в Julia. Чтобы из стандартного режима REPL перейти в режим help, требуется набрать julia>?+<enter>
Тогда,например, можно будет набрать help>Robot+<enter>, и получить интересующую информацию. 
Также важно иметь в виду, что функция include осуществляет просто вставку соответствующего программного кода (текста). Поэтому если include(...) выполнить более одного раза, то в последующем это приведет к ошибке.

##Создание объекта типа Robot с той или иной начальной обстановкой 

Для этого предусмотрены следующие варианты вызова конструктора Robot.

1. r=Robot()

2. r=Robot(<числло_строк_клеток_поля>,<число_столбцов_клеток_поля>)

3. r=Robot(<имя_файла_с_oбстановкой>)

4. r=Robot(...; animate=true)

В первом случае создается ограниченное рамкой поле 11x12 без внутренних перегородок и маркеров в клетках, с положением робота в юго-восточном (нижнем левом) углу.
Во втором - поле будет иметь указанные размеры
В третьем - обстановка на поле будет соответствовать данным, загруженным из соответствующего файла; рекомендуется для таких файлов использовать расширение .sit (от слова situation).

Во всех 3х случаях создается объект r типа Robot, содержащий структуру данных с соответствующей обстановкой. При выполнении команд робота эта внутренняя структура данных может изменяться, но визуализации обстановки на поле нет.

При желании посмотреть текущую обстановку следует воспользоваться функцией show(r).
В результате ее выполнения будет открыто графическое окно с текущей обстановкой.
При необходимости отредактировать текущуюю обстановку с помощью мыши функцию show следует вызывать с ключевым словом edit в значении true: show(r; edit=true).

При желании сохранить текущую обстановку в файле следует воспользоваться функцией 
save(r, <имя_файла>).

Кроме этого, еще имеется возможность запустить робота с анимацией выполняемых им действий, указав значение true ключевого слово animate:  r=Robot(...; animate=true), где вместо многоточия должны быть указаны фактические параметры (или они должны отсутствовать) в соответствии с первыми 3-мя вариантами использования конструктора. При этом функцию show использовать будет уже нельзя (это привело бы к ошибке времени выполнения). Но все функции графического окна, открывавшегося прежде при вызове функции show, будут теперь присущи аналогичному графическому окну, открывающемуся автоматически при вызове конструктора. С помощью этого окна можно отслеживать все действия робота в режиме анимации. Однако это приводит к дополнительным временным задержкам, не желательным, может быть, при выполненнии роботом объемных действий.


##О рекомендуемых источниках информации о языке Julia

Для изучения основ языка может быть рекомендован интернет-ресурс https://techytok.com/from-zero-to-julia/ (это англоязычный ресур, но с использованием google-переводчика им вполне могут пользоваться даже не владеющие английским языком). Дополнительно полезную информацию и статьи о julialang на русском языке можно найти,  на https://habr.com/ru/hub/julia/. Разумеется, имеется фирменная документация https://docs.julialang.org/en/v1/ вполне хорошего качества. В интернете также можно найти несколько методических пособий, посвященных языку Julia, на русском языке, например, http://cmp.phys.msu.ru/ru/staff/antonyuk, http://www.lib.unn.ru/students/src/JULIA_tutorial.pdf (последнее пособие содержит также уже некоторые устаревшие сведения, т.к. язык бурно развивался в последующие годы). Важно еще отметить некоторое (поверхностное) сходство языка Julia с языком Python, что позволяет, например, определить имя какой-либо интересующей стандартной функции Julia (велика вероятность того, что она называется также как и в Python, но, на сегдняшнй день, инфрормацию на русском языке по языку Python найти значительно проще). 

##Пример программы (хорошо структурированной), управляющей роботом 

Пусть требуется решить следующую задача.
ДАНО: Робот находится в произвольной клетке ограниченного прямоугольного поля без внутренних перегородок и маркеров
РЕЗУЛЬТАТ: Робот - в исходном положении в центре прямого креста из маркеров, расставленных вплоть до внешней рамки

Решение.

function put_krest(r::Robot)

    for side in HorizonSide

        putmarkers!(r,side)

        move_by_markers(r,inverse(side))

    end

    putmarker!(r)

end

putmarkers!(r::Robot,side::HorizonSide) = while isborder(r,side)==false 

    move!(r,side)

    putmarker!(r)

end

move_by_markers(r::Robot,side::HorizonSide) = while ismarker(r)==true 

    move!(r,side) 

end

inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4)) 

Если данные определения функций размещены, например, в файле example.jl, то
выполнить функцию put_krest из REPL нужно будет следующим образом.

julia> include("robot.jl")

lulia> r=Robot(animate=true) 

julia># в открывшемся окне с помощью мыши можно поставить робота в любое требуемое начальное положение

julia> put_krest!(r)