Перечень функций составляющих командный интерфейс "робота" (с помощью которго, и только с помощью которого, с ним можно взаимодействовать):
    - move!(::Robot,::HorizonSide)::Nothing - перемещает робота ровно на 1 клетку в указанном направлении
    - isborder(::Robot,::HorizonSide)::Bool - проверяет наличие перегородки в указанном направлении
    - putmarker!(::Robot)::Nothing - ставит маркер в клетке с роботом
    - ismarker(::Robot)::Bool - проверяет наличие маркера в клетке с роботом 
    - temperature(::Robot)::Int - возвращает температуру клетки с роботом
    - show(::Robor)::Nothing - открывает окно с обстановкой на поле (без возможности редактирования)
    - show!(::Robor)::Nothing - открывает окно с обстановкой на поле и предоставляет возможность редактирования обстановки
    - save(::Robot, ::AbstractString) - сохраняет текущую обстановку в указанном файле
(здесь всюду на позициях параметров каждой из функций указаны только типы парметров)

Пусть при этом требуется решить следующую задачу.

    ДАНО: Робот находится в произвольной клетке ограниченного прямоугольного поля без внутренних перегородок и маркеров

    РЕЗУЛЬТАТ: Робот - в исходном положении в центре прямого креста из маркеров, расставленных вплоть до внешней рамки

При правильном подходе к программированию целью должно быть не просто написать код, который хоть как-нибудь даст решение данной конкретной задачи, но написать его так, чтобы он был при этом еще и ХОРОШО СТPУКТУРИРОВАН. Это особенно важно, если предполагается дальнейшая модернизация кода и/или работа в команде программистов. Ну и просто - если иметь целью научится  с минимальными усилиями писать надежно работающие программы, в которых сможет разобраться кто-нибудь еще кроме их автора, и то лишь на момент разработки (программистам хорохо известно, что, уже спустя довольно короткий интервал времени, свой собственный код начинает восприниматься как чужой). Но чтобы этому научиться, требуется приложить определенные усилия, и иногда перебарыть в себе, в общем, вполне естественное желание в творческом порыве, никого не слушая, все делать по-своему.

Ниже приведен код на языке Julia, который соответствует данным требованиям. Примерно такой код (конечно, тут возможны варианты), скорее всего, должен получиться, если следовать технологии проектирования "сверху вниз". 
Полученный код в данном случае состоит из главной функции и 3-х вспомогательных (подпрограмм):

    function mark_kross!(r::Robot) # - главная функция  
        for side in (HorizonSide(i) for i=0:3) # - перебор всех возможных направлений
            putmarkers!(r,side)
            move_by_markers(r,inverse(side))
        end
        putmarker!(r)
    end

    # Всюду в заданном направлении ставит маркеры вплоть до перегородки, но в исходной клетке маркер не ставит
    putmarkers!(r::Robot,side::HorizonSide) = while isborder(r,side)==false 
        move!(r,side)
        putmarker!(r)
    end

    # Перемещает робота в заданном направлении пока, пока он находится в клетке с маркером (в итоге робот окажется в клетке без маркера)
    move_by_markers(r::Robot,side::HorizonSide) = while ismarker(r)==true 
        move!(r,side) 
    end

    # Возвращает направление, противоположное заданному
    inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4)) 

Обычно определение функции стоит дополнять кратким комментарием, пояснящим назначение функции (в примере - это строки, начинающиеся с символа #)

По-видимому, необходимо сразу дать пояснение, почему имена некоторых функций завершаются символом "!". Дело в том, что в языке Julia действует неформальное  
соглашение, согласно которому все функции, изменяющие (потенциально способные изменять) данные, содержащиеся в своих аргументах, получаемых по сслылке, следует именовать с восклицательным знаком в конце.

## Технология проектирования "сверху вниз"
Как уже упоминалось, записанный выше программный код может быть получен путем проектирования по технологии "сверху вниз". Это основная технология, применяющаяся в программировании. Суть ее в следующем.

- Исходная задача должна быть расчленена на ряд подзадч (более простых), каждой из которых будет соответствовать некоторая вспомогательная функция.
- Каждой выделенной подзадаче (функции) должно быть присвоено имя и определено какие потребуются для нее "входные" данные и какие - "выходные". Входные данные, как правило (но не всегда), будут представляться параметрами функции, а выходные - кортежем возвращаемых ею значений.
- После этого, используя только имена выделенных вспомогательных функций, следует записать алгоритм решения всей задачи, так, как будто бы эти выделенные вспомогательные функции уже реализованы. Очень важный момент здесь заключается в том, что к реализации вспомогательных функций надо переходить уже только после того, как выполнен данный пункт.
- Далее каждая из выделенных подзадач решается в точности по той же схеме. Этот процесс, который можно назвать процессом последовательной детелицации алгоритма, завершается когда выделяемые поддзадачи не начнут совпадать с командами исполнителя (в нашем случае - "робота").
  
Сам по себе процесс расчленения задачи на подзадачи является творческим и не формализуется. Варианты расчленения тоже могут быть разными, проблема состоит в том, чтобы найти наиболее удачный способ. Иногда процесс расчления (декомпозиции) может "заходить в тупик", и тогда приходится возвращаться к его началу. 
На начальном этапе декомпозиции бывает целесообразно использовать так называемый псевдокод - неформальую запись алгорима, часто в виде смеси языковых конструкций с почти обычным текста.

В данном случае, например, первоначальный псевдокод мог бы выглядеть так:

    for side - очередное (одно из 4х) направление горизонта
        ставить маркеры до упора в направлении side
        вернуться назад по расставленным маркерам
    end
    поставить маркер

На следующем шаге проектирвания появляется уже (приведенный выше) вполне формальный код:

    function mark_kross!(r::Robot) # - главная функция  
        for side in (HorizonSide(i) for i=0:3) # - перебор всех возможных направлений
            putmarkers!(r,side)
            move_by_markers(r,inverse(side))
        end
        putmarker!(r)
    end

После чего уже должны быть по очереди реализованы все задуманные здесь вспомогательные функции, которые в нашем случае уже достаточно просты, чтобы быть реализованными сразу, без предварительного использования псевдокода.

Приведенное выше решение, однако, не является единственно возможным. Так, функцию putmarkers! уместно было бы реализовать еще и так:

    putmarkers!(r::Robot, side::HorizonSide) = while move_if_possible!(r, side) == true
        putmarker!(r)
    end

где была задумана еще одна вспомогательная функция:

    # Перемещает робота в заданном направлении, если это возможно, и возвращает true, если перемещение состоялось (в противном случае - false)
    move_if_possible!(r::Robot, side::HorizonSide)::Bool = if isborder(r, side)
        return false
    else 
        move!(r,side)
        return true
    end

Такое решение будет иметь преимущество перед прежним, если иметь в виду, что в дальнейшем может понадобится усовершенствовать функцию mark_kross! так, чтобы она работала и при наличии на поле внутренних перегородок. Потому что это позволило бы тогда ограничиться модернизацией только функции move_if_posible, оставив весь остальной код без изменений.

## Отладка программы по технологии "снизу вверх"

Если процесс проектирования может быть охарактеризован как "технология сверху вниз", то процесс отладки должен происходить "снизу вверх". Суть этого утверждения в том, что прежде чем начинать отладку функции более высокого иерархического уровня, использующей какие-либо подпрограммы, эти подпрограммы должны быть уже отлажены. Поэтому отладка должна начинаться с подпрограмм самого нижнего иерархического уровня и заканчиваться уже отладкой главной функции.

Если следовать этому принципу, то процесс поиска ошибок будет наиболее легким. При этом если стремиться к тому, чтобы  вспомогательные функции были как можно более простыми, то и отлаживать (находить возможные ошибки) их будет просто.


## О составлении описаний функций

Во всем этом процессе проектирования и отладки (и дальнейшего использования) очень важно научиться четко (и, по возможности, кратко) формулировать, что именно делает каждая вспомогательная функция. Такие формулировки следует фиксировать в виде соответствующих коментариев к заголовкам функций. 

Эти формулировки в том или ином виде должны заключать в себе пункты: "ДАНО" и "РЕЗУЛЬТАТ", подобно тому, как это имеет место в приведенной в самом начале формулировке задачи. Хотя реальные формулировки могут и не включать явно слов "ДАНО", "РЕЗУЛЬТАТ", но "ДАНО" и "РЕЗУЛЬТАТ" должны легко "выводиться" из записанных в формулировках утверждений.

Некоторая сложность при составлении таких формулировок может заключаться в необходимости составления их так, чтобы они соответствовали ВСЕМ ВОЗМОЖНЫМ случаям применения соответствующих функций.

Причем формулировки эти должны быть ПОЛНЫМИ - каждая "мелочь" может иметь решающее значение.

## Об аннотировании аргументов функций

Во всех приведенных здесь примерах в определениях функций типы их аргументы были аннотированы. Однако в языке Julia такая аннотация не является обязательной, т.е. можно было бы и не указывать типы аргументов функций, так же как это, например, имеет место в языке Python. Поэтому, если во всех приведенных примерах функций, убрать аннотацию типов аргументов, то по-прежнему все будет работать. 

Возможность аннотирования типов, в принципе, дает следующие преимущества.

- Функции с одним и темже именем, но с разными типами аргументов (и/или разным количеством аргументов) - это разные функции (в терминологии Julia - разные методы одной функции). Это то, что называется множественной диспетчерезацией (см., например, https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D1%82%D0%BE%D0%B4). Множественная диспетчеризация позволяет иметь специализированные вырианты (методы) функции для каждого набора типов аргументов (т.е. выполнять те или иные действия, в зависимости от типов).
- Заголовок определения функции с аннотированными типами аргументов делает более понятным их назначение (но отсутствие аннотирования всегда можно компенсировать в этом смысле подробным документирванием функции).
- Аннотирование типов аргументов предохраняет от потенциальных ошибок использования функции, причем такого рода ошибки могут быть обнаружены анализатором кода еще на этапе его редактирования (но отсутствие аннотирования аргументов функции компенсируется в этом смысле тем, что ошибки типизаци обычно легко выявляются при отладке программы).
  
Вообще, типы бывают абстрактными и конкретными. Все типы аргументов в приведенных примерах - конкретные. Абстрактные типы предназначены исключительно для создания иерархии типов путем использования механизма наследования. 

Использование конкретных типов при аннотировании аргументов функций - не всегда правильное решение, потому что это перпятствует обобщенному подходу к программированию, основанному на так называемых обобщенных функциях. 

Цель разработки обобщенной функции - сделать сферу ее применения максимально широкой без изменения кода реализации. 

Однако то, в каких именно случаях, и как лучше всего аннотировать аргументы функций, и как программировать обобщенно - это предмет отдельного обсуждения, покаже мы этот важный для проектирования моент проигнориовали. 

## Функции и файлы

Хотя определения функций и могут быть сделаны непосредственно в REPL, обычно все нужные определения, решающие задачу, размещают и хранят в отдельном файле (или - в нескольких файлах). Пусть в нашем случае такой файл будет иметь имя example.jl. 

Тогда, чтобы выполнить функцию mark_kross! из REPL нужно будет опредения этой и вспомогательных для нее функций вставить в REPL с помощью include("example.jl"). Вот вся последовательность необходимых действий.

    julia> include("robot.jl")

    julia> include("example.jl")

    lulia> r=Robot(animate=true) # возможно редактирование обстановки 

    julia> mark_kross!(r)

Разумеется, после внесения каких-либо изменений в файл example.jl, перед повторным вызовом mark_kross!(r) необходимо будет заново выполнить include("example.jl"). Причем, поскольку файл "example.jl" содержит лишь определения функций вне отдельного модуля (в языке Julia есть специальная синтаксичская конструкция - module, ограничивающая область видимости имен, и которая в данном случае не используется), то перезапуск REPL julia не потребуется.

## Справка по использованным синтаксическим конструкциям языка Julia

1. В языке Julia определение функции может иметь следующие варианты:
    function имя_функции(список_аргументов_функции)
        тело_функции
        return кортеж_возвращаемых_зеачений
    end
или
    function имя_функции(список_аргументов_функции)
        тело_функции
    end # - в этом случае возвращается значение последнего оператора в теле функции

Слово function в определении может и отсутствовать:

    имя_функции(список_аргументов_функции)=выражение_определяющее_функцию

Обычно так выглядят совсем короткие определения.

Кроме того, во всех вариантах определения функции после скобок со списком параметров (который может быть и пустым) можно, при желании, указывать тип возвращаемого функцией значения. Например, в заголовке одного из определений

    move_if_possible!(r::Robot,side::HorizonSide)::Bool

указано, что функция возвращает логическое значение.

2. Конструкция (HorizonSide(i) for i=0:3) представляет собой частный случай генератора последовательности. 

Т.е. если бы вместо (HorizonSide(i) for i=0:3) было бы [HorizonSide(i) for i=0:3], то это была бы операция "спискового включения" (как в Python), результатом которой в данном случае был бы вектор (массив) из 4-х элементов. Но в случае (HorizonSide(i) for i=0:3) массив не формируется, а генерируется (вычисляется) последовательность тех же значений, но не сразу, а по мере надобности. Таким образом, использование генератора вместо массива дает экономию памяти: не нужно хранить в памяти весь массив целиком (в данном случае, правда, эта экономия не очень то и существенна, ввиду малой длины последовательности).

1. "Арифметический" цикл 

Имеет вид:

    for очередное_значение in итерируемый_объект_из_которого_извлекаются_значения
       тело_цикла
    end

Примеры итерируемых объектов: массив (Array,Vector,Matrix), кортеж (Tuple), диапазон, генератор, множество (Set), словарь (Dict)

4. Цикл с предусловием 

Имеет вид:

    while условие_продолжения_цикла
        тело_цикла
    end

5. Оператор цикла (любого типа) в языке Julia имеет значение nothing (типа Nothing), что означает отсутсвие значения.

6. Оператор ветвления в Julia 

Имеет вид:

    if условие
        тело_секции_if
    else
        тело_секции_else
    end

Возможен также укороченный вариант:

    if условие
        тело_секции_if
    end

Или - самый общий вариант:

    if условие_1
        тело_секции_1
    elseif уловие_2
        тело_секции_2
    ...
    elseif условие_N
        тело_секции_N
    else
        тело_секции_else
    end

В любом случае, значением оператора if будет значение последнего оператора в теле фактически исполняемой секции, или - nothing - в случае, если ни одна из секций не была выполнена (такое возможно лишь при отсутствии секции else).

## Перезагрузка REPL Julia

При работе в REPL иногда возникает необходимость отменить ранее сделанные определения.

Так если, например, была создана переменная

    julia> x=10000

то удалить это ее из области памяти REPL окажется невозможным (невозможно удалить имя, а не изменить значение). Можно лишь присвоить этой переменной значение nothing (тип этого значения - Nothing), что будет означать "отсутствие" значения 

    julia> x=nothing

(значение-то, на самом деле есть, просто оно - nothing, поэтому и поставлены кавычки).

Если же была определена функция, например,

    julia> f(x::Int)=x^2

то удалить ее из области REPL тоже не получится. Но ее можно будет переопределить, например

    julia> f(x::Int)=x^3

Но вот если изменить при этом тип аргумента, например

    julia> f(x::Float64)=x^2

то окажется, что старое определение не будет отменено, а будет одновременно существовать два метода одной обобщенной (generic) функции (см. выше о множественной диспетчеризации).

В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции exit
    
    julia> exit()

В среде VS Code можно, однако, открыть еще и новый экземпляр REPL, и продолжить работу в нем, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).

## Немного о терминологии

В классических объектно-ориентированных языках программирования КЛАССЫ имеют МЕТОДЫ. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия "метод" чаще используется понятие "функция-член класса", а еще там есть функции, дружественные классу.

В таких языках КЛАСС - это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.

А вот в языке Julia вместо классов есть типы, у типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод СПЕЦИАЛИЗИРУЕТ обобщенную (generic) функцию.

Обычно также в классических ООП языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении Nord в языке Python могла бы выглядеть так: r.move(Nord). Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты соответствующего типа могут являться лишь обычными агргументами соответствующей функции.
