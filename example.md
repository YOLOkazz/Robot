# ПРИМЕР РЕШЕНИЯ ЗАДАЧИ

Пусть требуется решить следующую задачу:

**ДАНО:** Робот находится в произвольной клетке ограниченного прямоугольного поля без внутренних перегородок и маркеров.
**РЕЗУЛЬТАТ:** Робот — в исходном положении в центре прямого креста из маркеров, расставленных вплоть до внешней рамки.

При правильном подходе к программированию целью должно быть не просто написать код, который хоть как-нибудь даст решение данной конкретной задачи, но написать его так, чтобы он был при этом еще и *хорошо структурирован*. Это особенно важно, если предполагается дальнейшая модернизация кода и/или работа в команде программистов. Ну и просто — если иметь целью научится с минимальными усилиями писать надёжно работающие программы, в которых сможет разобраться кто-нибудь ещё, кроме их автора (и то лишь на момент разработки). Программистам хорошо известно, что уже спустя довольно короткий интервал времени свой собственный код начинает восприниматься как чужой.

Но чтобы этому научиться, требуется приложить определенные усилия, перебарывая в себе, в общем-то, вполне естественное желание в творческом порыве, никого не слушая, всё делать по-своему.

Ниже приведён код на языке Julia, который соответствует данным требованиям. Примерно такой код (конечно, тут возможны варианты), скорее всего, должен получиться, если следовать технологии проектирования «сверху вниз».

Код в данном случае состоит из главной функции и трёх вспомогательных (подпрограмм):

    function mark_kross!(r::Robot) # - главная функция  
        for side in (HorizonSide(i) for i=0:3) # - перебор всех возможных направлений
            putmarkers!(r,side)
            move_by_markers(r,inverse(side))
        end
        putmarker!(r)
    end

    # Всюду в заданном направлении ставит маркеры вплоть до перегородки, но в исходной клетке маркер не ставит
    putmarkers!(r::Robot,side::HorizonSide) = while isborder(r,side)==false 
        move!(r,side)
        putmarker!(r)
    end

    # Перемещает робота в заданном направлении пока, пока он находится в клетке с маркером (в итоге робот окажется в клетке без маркера)
    move_by_markers(r::Robot,side::HorizonSide) = while ismarker(r)==true 
        move!(r,side) 
    end

    # Возвращает направление, противоположное заданному
    inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4)) 

Обычно определение функции стоит дополнять кратким комментарием, пояснящим назначение функции. В данном примере это строки, начинающиеся с символа «`#`».

Стоит обратить внимание, что некоторые названия функций завершаются символом «`!`». Дело в том, что в языке Julia действует неформальное  
соглашение (то есть нарушать его можно, компилятор стерпит, но лучше не стоит), согласно которому все функции, изменяющие (точнее, потенциально способные изменять) данные, содержащиеся в их получаемых по сслылке аргументах, следует именовать с восклицательным знаком в конце. И только если функция гарантированно не изменяет получаемые по ссылке данные, восклицательный знак к её имени не добавляется.

## Технология проектирования «сверху вниз»

Как уже упоминалось, записанный выше программный код может быть получен путем проектирования по технологии «сверху вниз». Это основная технология, применяющаяся в программировании. Суть её в следующем.

- Исходная задача должна быть расчленена на ряд подзадач (более простых), каждой из которых будет соответствовать некоторая вспомогательная функция.
- Каждой выделенной подзадаче (функции) должно быть присвоено имя и определено, какие потребуются для неё входные данные и какие — выходные. Входные данные, как правило, будут представляться параметрами функции, а выходные - кортежем возвращаемых ею значений.
- После этого, используя только имена выделенных вспомогательных функций, следует записать алгоритм решения всей задачи. Причём сделать это так, как будто бы эти выделенные вспомогательные функции уже реализованы. Очень важный момент здесь заключается в том, что к реализации вспомогательных функций надо переходить уже только после того, как выполнен данный пункт. В противном случае происходит перенос внимания и основная задача «забывается», из-за чего впоследствии нарушается запланированная схема взаимодействия программных блоков.
- Далее каждая из выделенных подзадач решается в точности по той же схеме. Этот процесс, который можно назвать процессом последовательной детализации алгоритма, завершается когда выделяемые подзадачи не начнут совпадать с командами исполнителя (в нашем случае — Робота).
  
Сам по себе процесс расчленения задачи на подзадачи является творческим и не формализуется. Варианты расчленения тоже могут быть разными, проблема состоит в том, чтобы найти наиболее удачный способ. Иногда процесс расчленения (часто также называется декомпозицией) может заходить в тупик, и тогда приходится возвращаться к его началу.

На начальном этапе декомпозиции бывает целесообразно использовать так называемый псевдокод: неформальую запись алгорима, часто в виде смеси языковых конструкций с почти обычным текстом. В данном случае первоначальный псевдокод мог бы выглядеть, например, так:

    for side - очередное (одно из 4х) направление горизонта
        ставить маркеры до упора в направлении side
        вернуться назад по расставленным маркерам
    end
    поставить маркер

На следующем шаге проектирования появляется уже приведённый выше вполне формальный код:

    function mark_kross!(r::Robot) # - главная функция  
        for side in (HorizonSide(i) for i=0:3) # - перебор всех возможных направлений
            putmarkers!(r,side)
            move_by_markers(r,inverse(side))
        end
        putmarker!(r)
    end

После чего уже должны быть по очереди реализованы все задуманные здесь вспомогательные функции. В нашем случае они уже достаточно просты, чтобы быть реализованными сразу, без предварительного использования псевдокода.

Приведенное выше решение, однако, не является единственно возможным. Так, функцию putmarkers! можно было бы реализовать ещё и так:

    putmarkers!(r::Robot, side::HorizonSide) = while move_if_possible!(r, side) == true
        putmarker!(r)
    end

при этом появляется ещё одна вспомогательная функция:

    # Перемещает робота в заданном направлении, если это возможно, и возвращает true,
    # если перемещение состоялось; в противном случае - false.
    move_if_possible!(r::Robot, side::HorizonSide)::Bool = if isborder(r, side)
        return false
    else 
        move!(r,side)
        return true
    end

Такое решение будет иметь преимущество перед прежним, если иметь в виду, что в дальнейшем может понадобится усовершенствовать функцию `mark_kross!` так, чтобы она работала и при наличии на поле внутренних перегородок. Потому что это позволило бы тогда ограничиться модернизацией только функции `move_if_posible`, оставив весь остальной код без изменений.

## Отладка программы по технологии «снизу вверх»

Если процесс проектирования может быть охарактеризован как «технология сверху вниз», то процесс отладки должен происходить «снизу вверх». Суть этого утверждения в том, что прежде чем начинать отладку функции более высокого иерархического уровня, использующей какие-либо подпрограммы, эти подпрограммы должны быть уже отлажены. Поэтому отладка должна начинаться с подпрограмм самого нижнего иерархического уровня и заканчиваться уже отладкой главной функции.

Если следовать этому принципу, то процесс поиска и исправления ошибок будет максимально облегчён. При этом, если стремиться к тому, чтобы  вспомогательные функции были как можно более простыми, то и отлаживать (находить возможные ошибки) их будет просто.

## О составлении описаний функций

В процессе проектирования и отладки (и для дальнейшего использования) очень важно научиться чётко и, по возможности, кратко формулировать, что именно делает каждая вспомогательная функция. Такие формулировки следует фиксировать в виде соответствующих коментариев к заголовкам функций. 

Эти формулировки в том или ином виде должны заключать в себе пункты: **ДАНО** и **РЕЗУЛЬТАТ**, подобно тому, как это имеет место в приведенной в самом начале формулировке задачи. Хотя реальные формулировки могут и не включать явно этих слов, но **ДАНО** и **РЕЗУЛЬТАТ** должны легко выводиться из записанных в формулировках утверждений.

Некоторая сложность при составлении таких формулировок может заключаться в необходимости составления их так, чтобы они соответствовали *всем возможным* случаям применения соответствующих функций. Причем формулировки эти должны быть *полными*: каждая мелочь может иметь решающее значение.

## Об аннотировании аргументов функций

Во всех приведенных здесь примерах в определениях функций типы их аргументы были аннотированы. Однако в языке Julia такая аннотация не является обязательной. То есть, можно было бы и не указывать типы аргументов функций, так же как это, например, имеет место быть в языке Python. Поэтому, если во всех приведенных примерах функций убрать аннотацию типов аргументов, то по-прежнему всё будет работать. 

Возможность аннотирования типов даёт следующие преимущества.

- Функции с одним и тем же именем, но с разными типами аргументов (и/или разным количеством аргументов) — это разные функции (в терминологии Julia — разные методы одной функции). Это то, что называется [множественной диспетчеризацией](https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D1%82%D0%BE%D0%B4). Множественная диспетчеризация позволяет иметь специализированные вырианты (методы) функции для каждого набора типов аргументов, то есть выполнять те или иные действия, в зависимости от их типов.
- Заголовок определения функции с аннотированными типами аргументов делает более понятным их назначение (отсутствие аннотирования всегда можно компенсировать в этом смысле подробным документированием самой функции).
- Аннотирование типов аргументов предохраняет от потенциальных ошибок использования функции. Причём, что особенно ценно, такого рода ошибки могут быть обнаружены анализатором кода ещё на этапе подготовки программы. Отсутствие аннотирования аргументов функции компенсируется в этом смысле тем, что ошибки типизаци обычно (но не всегда) легко выявляются при отладке программы.

Вообще, типы бывают абстрактными и конкретными. Все типы аргументов в приведённых примерах — конкретные. Абстрактные типы предназначены исключительно для создания иерархии типов путём использования механизма наследования. 

Использование конкретных типов при аннотировании аргументов функций - не всегда правильное решение, потому что это препятствует обобщённому подходу к программированию, основанному на так называемых обобщённых функциях. Цель разработки обобщённой функции — сделать сферу её применения максимально широкой без изменения кода реализации. Однако то, в каких именно случаях, и как лучше всего аннотировать аргументы функций, и как программировать обобщённо — это предмет отдельного обсуждения, пока что мы этот, безусловно важный для проектирования, момент игнорируем.
