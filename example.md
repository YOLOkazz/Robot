# ПРИМЕР РЕШЕНИЯ ЗАДАЧИ

Пусть при этом требуется решить следующую задачу:

**ДАНО:** Робот находится в произвольной клетке ограниченного прямоугольного поля без внутренних перегородок и маркеров.
**РЕЗУЛЬТАТ:** Робот — в исходном положении в центре прямого креста из маркеров, расставленных вплоть до внешней рамки.

При правильном подходе к программированию целью должно быть не просто написать код, который хоть как-нибудь даст решение данной конкретной задачи, но написать его так, чтобы он был при этом еще и *хорошо структурирован*. Это особенно важно, если предполагается дальнейшая модернизация кода и/или работа в команде программистов. Ну и просто — если иметь целью научится с минимальными усилиями писать надёжно работающие программы, в которых сможет разобраться кто-нибудь ещё, кроме их автора (и то лишь на момент разработки). Программистам хорошо известно, что уже спустя довольно короткий интервал времени свой собственный код начинает восприниматься как чужой.

Но чтобы этому научиться, требуется приложить определенные усилия, перебарывая в себе, в общем-то, вполне естественное желание в творческом порыве, никого не слушая, всё делать по-своему.

Ниже приведён код на языке Julia, который соответствует данным требованиям. Примерно такой код (конечно, тут возможны варианты), скорее всего, должен получиться, если следовать технологии проектирования «сверху вниз».

Код в данном случае состоит из главной функции и трёх вспомогательных (подпрограмм):

    function mark_kross!(r::Robot) # - главная функция  
        for side in (HorizonSide(i) for i=0:3) # - перебор всех возможных направлений
            putmarkers!(r,side)
            move_by_markers(r,inverse(side))
        end
        putmarker!(r)
    end

    # Всюду в заданном направлении ставит маркеры вплоть до перегородки, но в исходной клетке маркер не ставит
    putmarkers!(r::Robot,side::HorizonSide) = while isborder(r,side)==false 
        move!(r,side)
        putmarker!(r)
    end

    # Перемещает робота в заданном направлении пока, пока он находится в клетке с маркером (в итоге робот окажется в клетке без маркера)
    move_by_markers(r::Robot,side::HorizonSide) = while ismarker(r)==true 
        move!(r,side) 
    end

    # Возвращает направление, противоположное заданному
    inverse(side::HorizonSide) = HorizonSide(mod(Int(side)+2, 4)) 

Обычно определение функции стоит дополнять кратким комментарием, пояснящим назначение функции. В данном примере это строки, начинающиеся с символа «`#`».

Стоит обратить внимание, что некоторые названия функций завершаются символом «`!`». Дело в том, что в языке Julia действует неформальное  
соглашение (то есть нарушать его можно, компилятор стерпит, но лучше не стоит), согласно которому все функции, изменяющие (точнее, потенциально способные изменять) данные, содержащиеся в их получаемых по сслылке аргументах, следует именовать с восклицательным знаком в конце. И только если функция гарантированно не изменяет получаемые по ссылке данные, восклицательный знак к её имени не добавляется.

## Технология проектирования «сверху вниз»

Как уже упоминалось, записанный выше программный код может быть получен путем проектирования по технологии «сверху вниз». Это основная технология, применяющаяся в программировании. Суть её в следующем.

- Исходная задача должна быть расчленена на ряд подзадач (более простых), каждой из которых будет соответствовать некоторая вспомогательная функция.
- Каждой выделенной подзадаче (функции) должно быть присвоено имя и определено, какие потребуются для неё входные данные и какие — выходные. Входные данные, как правило, будут представляться параметрами функции, а выходные - кортежем возвращаемых ею значений.
- После этого, используя только имена выделенных вспомогательных функций, следует записать алгоритм решения всей задачи. Причём сделать это так, как будто бы эти выделенные вспомогательные функции уже реализованы. Очень важный момент здесь заключается в том, что к реализации вспомогательных функций надо переходить уже только после того, как выполнен данный пункт. В противном случае происходит перенос внимания и основная задача «забывается», из-за чего впоследствии нарушается запланированная схема взаимодействия программных блоков.
- Далее каждая из выделенных подзадач решается в точности по той же схеме. Этот процесс, который можно назвать процессом последовательной детализации алгоритма, завершается когда выделяемые подзадачи не начнут совпадать с командами исполнителя (в нашем случае — Робота).
  
Сам по себе процесс расчленения задачи на подзадачи является творческим и не формализуется. Варианты расчленения тоже могут быть разными, проблема состоит в том, чтобы найти наиболее удачный способ. Иногда процесс расчленения (часто также называется декомпозицией) может заходить в тупик, и тогда приходится возвращаться к его началу.

На начальном этапе декомпозиции бывает целесообразно использовать так называемый псевдокод: неформальую запись алгорима, часто в виде смеси языковых конструкций с почти обычным текстом. В данном случае первоначальный псевдокод мог бы выглядеть, например, так:

    for side - очередное (одно из 4х) направление горизонта
        ставить маркеры до упора в направлении side
        вернуться назад по расставленным маркерам
    end
    поставить маркер

На следующем шаге проектирования появляется уже приведённый выше вполне формальный код:

    function mark_kross!(r::Robot) # - главная функция  
        for side in (HorizonSide(i) for i=0:3) # - перебор всех возможных направлений
            putmarkers!(r,side)
            move_by_markers(r,inverse(side))
        end
        putmarker!(r)
    end

После чего уже должны быть по очереди реализованы все задуманные здесь вспомогательные функции. В нашем случае они уже достаточно просты, чтобы быть реализованными сразу, без предварительного использования псевдокода.

Приведенное выше решение, однако, не является единственно возможным. Так, функцию putmarkers! можно было бы реализовать ещё и так:

    putmarkers!(r::Robot, side::HorizonSide) = while move_if_possible!(r, side) == true
        putmarker!(r)
    end

при этом появляется ещё одна вспомогательная функция:

    # Перемещает робота в заданном направлении, если это возможно, и возвращает true,
    # если перемещение состоялось; в противном случае - false.
    move_if_possible!(r::Robot, side::HorizonSide)::Bool = if isborder(r, side)
        return false
    else 
        move!(r,side)
        return true
    end

Такое решение будет иметь преимущество перед прежним, если иметь в виду, что в дальнейшем может понадобится усовершенствовать функцию `mark_kross!` так, чтобы она работала и при наличии на поле внутренних перегородок. Потому что это позволило бы тогда ограничиться модернизацией только функции `move_if_posible`, оставив весь остальной код без изменений.

## Отладка программы по технологии «снизу вверх»

Если процесс проектирования может быть охарактеризован как «технология сверху вниз», то процесс отладки должен происходить «снизу вверх». Суть этого утверждения в том, что прежде чем начинать отладку функции более высокого иерархического уровня, использующей какие-либо подпрограммы, эти подпрограммы должны быть уже отлажены. Поэтому отладка должна начинаться с подпрограмм самого нижнего иерархического уровня и заканчиваться уже отладкой главной функции.

Если следовать этому принципу, то процесс поиска и исправления ошибок будет максимально облегчён. При этом, если стремиться к тому, чтобы  вспомогательные функции были как можно более простыми, то и отлаживать (находить возможные ошибки) их будет просто.
