# ОСОБЕННОСТИ ИСПОЛЬЗОВАНИЯ ЯЗЫКА JULIA

## Функции и файлы

Хотя определения функций и могут быть сделаны непосредственно в REPL, обычно все нужные определения, решающие задачу, размещают и хранят в отдельном файле, или в нескольких файлах. Пусть в нашем случае такой файл будет иметь имя `example.jl`. Тогда, чтобы выполнить функцию `mark_kross!` из REPL нужно будет определения этой и вспомогательных для неё функций вставить в REPL с помощью include("example.jl"). Вот вся последовательность необходимых действий:

    julia> include("robot.jl")
    julia> include("example.jl")
    lulia> r=Robot(animate=true) # возможно редактирование обстановки 
    julia> mark_kross!(r)

Разумеется, после внесения каких-либо изменений в файл `example.jl` перед повторным вызовом `mark_kross!(r)` необходимо будет заново выполнить `include("example.jl")`. Причём, поскольку файл `example.jl` содержит лишь определения функций вне отдельного модуля (в языке Julia есть специальная синтаксичская конструкция — `module`, ограничивающая область видимости имён, и которая в данном случае не используется), то перезапуск REPL julia не потребуется.

## Справка по использованным синтаксическим конструкциям языка Julia

### Функции

В языке Julia определение функции может иметь следующие варианты:

    function имя_функции(список_аргументов_функции)
        тело_функции
        return кортеж_возвращаемых_зеачений
    end

или

    function имя_функции(список_аргументов_функции)
        тело_функции
    end # - в этом случае возвращается значение последнего оператора в теле функции

Слово `function` в определении может и отсутствовать:

    имя_функции(список_аргументов_функции)=выражение_определяющее_функцию

Обычно так выглядят совсем короткие определения.

Кроме того, во всех вариантах определения функции после скобок со списком параметров (который может быть и пустым) можно, при желании, указывать тип возвращаемого функцией значения. Например, в заголовке одного из определений:

    move_if_possible!(r::Robot,side::HorizonSide)::Bool

указано, что функция возвращает логическое значение.

### Последовательности

Конструкция `(HorizonSide(i) for i=0:3)` представляет собой частный случай генератора последовательности. 

То есть, если бы вместо `(HorizonSide(i) for i=0:3)` было бы `\[HorizonSide(i) for i=0:3]`, то это была бы операция «спискового включения» (как в Python), результатом которой в данном случае был бы вектор (массив) из четырёх элементов. Но в случае `(HorizonSide(i) for i=0:3)` массив не формируется, а генерируется (вычисляется) последовательность тех же значений, только не сразу, а по мере надобности. Таким образом, использование генератора вместо массива даёт экономию памяти: не нужно хранить в памяти весь массив целиком (в данном случае, правда, эта экономия не очень то и существенна, ввиду малой длины последовательности).

### Арифметический цикл

Арифметический цикл имеет вид:

    for очередное_значение in итерируемый_объект_из_которого_извлекаются_значения
       тело_цикла
    end

Примеры итерируемых объектов: массив (`Array`, `Vector`, `Matrix`), кортеж (`Tuple`), диапазон, генератор, множество (`Set`), словарь (`Dict`).

### Цикл с предусловием

Цикл с предусловием имеет вид:

    while условие_продолжения_цикла
        тело_цикла
    end

### Значение оператора цикла

Оператор цикла (любого типа) в языке Julia имеет значение `nothing` (типа `Nothing`), что означает отсутсвие значения.

### Оператор ветвления

Оператор ветвления имеет вид:

    if условие
        тело_секции_отрабатывающей_если_условие_выполнено
    else
        тело_секции_отрабатывающей_в_противном_случае
    end

Возможен также укороченный вариант:

    if условие
        тело_секции_отрабатывающей_если_условие_выполнено
    end

Самый общий вариант:

    if условие_1
        тело_секции_отрабатывающей_если_условие_1_выполнено
    elseif уловие_2
        тело_секции_отрабатывающей_если_условие_2_выполнено
    ...
    elseif условие_N
       тело_секции_отрабатывающей_если_условие_N_выполнено
     else
       тело_секции_отрабатывающей_если_ни_одно_условие_не_выполнено
     end

В любом случае значением оператора `if` будет значение последнего оператора в теле фактически исполняемой секции, или `nothing` — в случае, если ни одна из секций не была выполнена (такое возможно лишь при отсутствии секции `else`).

## Перезагрузка REPL Julia

При работе в REPL иногда возникает необходимость отменить ранее сделанные определения. Напимер, если была создана переменная `x`:

    julia> x=10000

то удалить её саму из области памяти REPL окажется невозможным. То есть, невозможно именно удалить имя, а не изменить значение. Можно лишь присвоить этой переменной значение `nothing` (тип этого значения — `Nothing`), что будет означать «отсутствие» значения.

    julia> x=nothing

(значение-то на самом деле есть, просто оно — `nothing`, поэтому и поставлены кавычки).

Если была определена функция, например,

    julia> f(x::Int)=x^2

то удалить её из области REPL тоже не получится. Но её можно будет переопределить, сохранив типы аргументов, например:

    julia> f(x::Int)=x^3

Но вот если изменить при этом тип аргумента, например:

    julia> f(x::Float64)=x^2

то окажется, что старое определение не исчезнет, а будет одновременно существовать два метода одной обобщённой (`generic`) функции (см. выше о множественной диспетчеризации).

В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции `exit`:
    
    julia> exit()

В среде VS Code можно, однако, открыть ещё и новый экземпляр REPL, и продолжить работу в нём, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).

## Немного о терминологии

В классических объектно-ориентированных языках программирования говорят о *классах*, имеющих *методы*. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия «метод» используется понятие «функция-член класса», а ещё там есть функции, дружественные классу.

В таких языках *класс* — это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.

А вот в языке Julia вместо классов есть типы. У типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод *специализирует* обобщённую (`generic`) функцию.

Обычно также в ОО-языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении `Nord` в языке Python могла бы выглядеть так: `r.move(Nord)`. Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты соответствующего типа могут являться лишь обычными аргументами соответствующей функции.
