# ВВОДНЫЕ ЗАМЕЧАНИЯ О ЯЗЫКЕ JULIA

Если вы знакомы с языком Python, то очень многое в языке Julia вам покажется знакомым.
Но есть и существенные различия. 

Напирмер, в языке Julia отступы не имеют принципиального значения, такое как они имеют в языке Python, где отступы определяют структуру кода. 

Не надо также ставить двоеточия вконце заголовов функций, циклов и т.д. Вместо всего этого используется ключевое слово `end`, ограничивающее тело той или иной конструкции языка (см. ниже).

## Функции

Например, определение функции может выглядеть так

    function f(x)
        return x^2
    end

или так

    function f(x)
        x^2 # функция всегда возвращает значение последнего оператора в своем теле
    end

или даже так

    f(x)=x^2

(последний способ обычно используют для совсем коротких определений).

Однако в отличие от языка Python, где типы аргументов функций и возвращаемый функцией результат не аннотируются, в языке могут быть аннотированы, но делать это не обязательно. 

Например, можно было бы дать еще следующие 2 определения

    function f(x::Int)
        return x^3
    end

    function f(x::Float64)
        return x^4
    end

В результате получим еще 2 метода (варианта) функции f, а всего, если учесть передыдущее определение, - будет уже 3 метода. В первом определении, где тип аргумента явно не аннотировался, он (тип), на самом деле, имел значение Any - тип, стоящий во главе иерархии всех типов Julia. И все эти 3 определения одновременно быдут существовать, какое из них будет использовано - зависит от фактического типа аргумента функции (т.е. с аргументом какого типа будет вызов функции). Это называется множественной диспетчеризацией. 

Зачем нужна множественная диспетчеризация, и как ей правильно пользоваться в языке Julia - это предмет отдельного разговора. Но заранее заметим, что эта тема имеет в Julia первостепеное значение. 

## Циклы
Циклы в Julia выглядят, например, так
    
    for i in 1:10
        println(i)
    end

или так

    i=10
    while i>0
        println(i)
        i-=1
    end

## Значение конструкции цикла
В языке Julia любой оператор цикла имеет значение nothing (Nonthing), что обозначает "отсутствие" значения. Это значит, что это значение можно присвоить какой-либо переменной или вернуть из функции (речь, конечно, идет о некоторой формальности).

## Вложенные циклы

Любой цикл может содержать в своем теле другой цикл. Такие циклы называются вложенными.

## Операторы изменения поряка выполнения цикла

Иногда бывает необходимо прервать выполнение цикла при выполнении некоторого дополнительного условия - для этого существует оператор `break`. 

Имеется также оператор `continue`, который в отличии от break не прерывеат выполнение цикла, а только переключает процесс на следующую итерацию, не дожидаясь выполнения  всех озаписанныз после него действий в теле цикла.

## Ветвления

Ветвления выглядят в общем случае так

    if условие
        тело
    end

    if условие
        тело_if
    else
        тело_else
    end

    if условие_1
        тело_1
    elseif условие_2
        тело_2
    ...
    elseif условие_N # число провряемых усорвий может быть любым
        тело_N
    else # эта секция может и отсутствовать
        тело_else
    end

## Значение ветвления

В языке Julia начением оператора ветвления является значение последнего оператора в теле выполняемого блока.
Например, если

    a=if 2>0
        10
    else
        -10
    end

то в результате переменная a получит значение 10.

## Переменные, типы, операции, выражения, присваивания

Также как и Python язык Julia является языком с динамической типизацией и с выводом типов. Первое означает, что переменная с заданным именем может изменить свой тип в процессе выполнения программы. А второе означает, что типы значений, которыми инициализируются переменные не обязательно явно указывать, компилятор Julia сумеет правильно определить (вывести) тип значения исходя из контекста (например, из способа записи числового значения). 

Например
    x=1   # - тип переменной будет Int64 (или просто - Int)
    x=1.0 # - тип переменной (с прежним именем) будет Float64
    x=1//2 # - тип переменной будет Ranional{Int64}

С числовыми значениями можно выполнять обычные арифметические опрерации и применять к ним стандартные математические функции. Пример математического выражения

    1+2*(sin(x)-cos(y))/exp(x+y^3)

Имеются логические значения true, false (тип Bool), к ним применимы стандартные логические операции `&&` ("и"), `||` ("или"), `!` ("не")
(надо с осторожностью относится к побировым опереациям `&`, `|`, `~`, и неиспользовать их вместо соответствующих логических операций - это может приводить к досадным недороазумениям)

Операции сравнения: `==` ("равно"), `===` ("тождественно равно"), `!=`, `!==`, `<`, `>`, `<=`, `>=`.
Возможны также двойные сравнения `1<2<3` - даст значение `true`. 

## Массивы, генераторы, кортежи, строки

Индексация в массивах в языке Julia начинается с 1 (а в языке Python - с 0). Индексы записываются в квадратных скобках. 

Например

    a=[10,20,30,40]

    a[1] - это 10

    a[end] - это 40

    length(a) - длина массива, равна 4

    push!(a,50) - добавляет в конец массива еще один элемент (50)

    pop(a) - извлекает из конца массива элемент

    a[2]=100 - присваивает новое значение 2-му элементу массива
    
Переменная a - это ссылка, т.е. если

    b=a 

то b - это будет ссылка на тот же самый массив, так что
изменение значения элемента в b будет означать и изменение в a. Напримр

    b[2]=0

даст, что a[2] - это 0.

Чтбы получить копию массива, надо использовать функцию copy, например,

    с=copy(a)

    c[1]=1000

но a[1] - по прежнему будет иметь значение 10.

Кроме массивов в языке Julia, как и в Python, есть еще диапазоны.
Но в Julia они записвываются иначе. 

Например `1:10`, или `1:2:10` (2 - это шаг, он записывается в середине конструкции; по умолчанию шаг равен 1). 

Дапазоны в Julia, в отличие о от Python, являются замкнутыми, т.е., например, число 10 в ходит в `1:10`, и число 11 входит в `1:2:11` (но вот число 10 в `1:2:10`, разумеется, - не входит). 

Кроме того начальное, конечное значения диапазона и щаг не обязательно целые числа, они могут быть и с плавающей точкой.

Массивы могут создаваться разными способами. Например, можно использовать так называемое списковое включение:
    
    [i^2 for i in 1:10]

В данном случае получится массив квадратов первых 10 натуральных чисел. Эта конструкция вполне аналогична тому, что есть Python.
    
Работа с массивами в языке Julia очень удобна и эффективно реализована, и в этом (а также во многом другом) Julia явно превосходит язык Python.

А вот такая конструкция
    
    (i^2 for i in 1:10)

подобна предыдущей, но результатом ее выполнения является такназываемый генератор (последовательности), а не массив. 

Отличие в том, что все члены последовательности сразу не размещаются в памяти, а генерируются по мере надобности по очереди. 

Например, такая конструкция могла бы съекономить расход памяти в следующем цикле

    for k in (i^2 for i in 1:1_000_000) ... end

Генераторы не нужно путать с кортежами (Tuple), которые внешне выглядят похоже:

    (1,2,3,4)

Это кортеж - в отличие от массивов кортежи не изменяемы, т.е. изменить значение отдельного элемента кортежа нельзя. 

Например

    a=(10,20,30,40)

    a[1] # - равно 10

    a[1]=100 # - ошибка: кортеж изменить нельзя

Кортежи могут использоваться в оперторе присваивания

    a,b,c = 1,2,3 # это тоже самое, что и (a,b,c) = (1,2,3)

в результате получится, что `a=1, b=2, c=3`.

Картеж из одного элемента записвывается с помощью запятой в конце, например (2,) - это кортеж.

Строки - тоже неизменяемые объекты, пример строки

    s="abcdefgh"

    s[1] # - это есть символ ASCII 'a' (не строка)

    s[1]='b' # - ошибка: изменить строку не возможно

Со строками возможны операции:

    - "absd"*"efgh" # - операция конкатенации (в Python аналогичная операция записывается с помощью символа "+")
    - "abc"^3 # - операция дублирования, в данном случае - 3х кратного (в Python аналогичная операция записывается с помощью - "*")
    - n=3; "number = $(n)" - вставляет в строку на место переменной n ее значение (это называется "интерпляцией строк") 

## Стандартные контейнеры

В языке Julia, как и в языке Python, помимо массивов существуют также множества (Set) и словари (Dict).
  
## Интроспекция

Для выяснения того, какого типа то или иное значение, имеется встроенная функция typeof.
Также в REPL имеется удобная встроенная система помощи, с помощью которой можно получить много полезной информации о типах данных и функциях языка Julia.

## Дальнейшие ссведения о языке
Дальнейшие сведения о языке Julia и его типах данных, в частности, можно почерпнуть, например, [здесь](https://biologo.ru/korotko-o-yazike-programmirovaniya/index.pdf),
а также [здесь](https://techytok.com/from-zero-to-julia/).

Для более полного ознакомления с языком следует обращаться к [фирменной документации](https://docs.julialang.org/en/v1/)

### Оператор ветвления

Оператор ветвления имеет вид:

    if условие
        тело_секции_отрабатывающей_если_условие_выполнено
    else
        тело_секции_отрабатывающей_в_противном_случае
    end

Возможен также укороченный вариант:

    if условие
        тело_секции_отрабатывающей_если_условие_выполнено
    end

Самый общий вариант:

    if условие_1
        тело_секции_отрабатывающей_если_условие_1_выполнено
    elseif уловие_2
        тело_секции_отрабатывающей_если_условие_2_выполнено
    ...
    elseif условие_N
       тело_секции_отрабатывающей_если_условие_N_выполнено
     else
       тело_секции_отрабатывающей_если_ни_одно_условие_не_выполнено
     end

В любом случае значением оператора `if` будет значение последнего оператора в теле фактически исполняемой секции, или `nothing` — в случае, если ни одна из секций не была выполнена (такое возможно лишь при отсутствии секции `else`).

## Перезагрузка REPL Julia

При работе в REPL иногда возникает необходимость отменить ранее сделанные определения. Напимер, если была создана переменная `x`:

    julia> x=10000

то удалить её саму из области памяти REPL окажется невозможным. То есть, невозможно именно удалить имя, а не изменить значение. Можно лишь присвоить этой переменной значение `nothing` (тип этого значения — `Nothing`), что будет означать «отсутствие» значения.

    julia> x=nothing

(значение-то на самом деле есть, просто оно — `nothing`, поэтому и поставлены кавычки).

Если была определена функция, например,

    julia> f(x::Int)=x^2

то удалить её из области REPL тоже не получится. Но её можно будет переопределить, сохранив типы аргументов, например:

    julia> f(x::Int)=x^3

Но вот если изменить при этом тип аргумента, например:

    julia> f(x::Float64)=x^2

то окажется, что старое определение не исчезнет, а будет одновременно существовать два метода одной обобщённой (`generic`) функции (см. выше о множественной диспетчеризации).

В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции `exit`:
    
    julia> exit()

В среде VS Code можно, однако, открыть ещё и новый экземпляр REPL, и продолжить работу в нём, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).

## Немного о терминологии

В классических объектно-ориентированных языках программирования говорят о *классах*, имеющих *методы*. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия «метод» используется понятие «функция-член класса», а ещё там есть функции, дружественные классу.

В таких языках *класс* — это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.

А вот в языке Julia вместо классов есть типы. У типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод *специализирует* обобщённую (`generic`) функцию.

Обычно также в объектно-ориентированных языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении `Nord` в языке Python могла бы выглядеть так: `r.move(Nord)`. Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты соответствующего типа могут являться лишь обычными аргументами соответствующей функции.

## O Julia и Python
Важно ещё отметить некоторое поверхностное сходство языка Julia с языком Python, благодаря чему, например, часто удаётся выяснить имя и описание какой-либо вдруг понадобившейся стандартной функции Julia (если по каким-то причинам не удалось сделать напрямую): велика вероятность того, что нужная функция называется и действует так же, как и в Python. При этом на сегодняшнй день информацию по языку Python на русском языке найти значительно проще.


--------------------------------

Источники дополнительной информации о языке Julia приведены [здесь](links.md)

Разбор примера программы имеется [здесь](example.md)