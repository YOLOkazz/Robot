# Особенности использования языка Julia

## О составлении описаний функций

В процессе проектирования и отладки (и дальнейшего использования) очень важно научиться чётко (и, по возможности, кратко) формулировать, что именно делает каждая вспомогательная функция. Такие формулировки следует фиксировать в виде соответствующих коментариев к заголовкам функций. 

Эти формулировки в том или ином виде должны заключать в себе пункты: **ДАНО** и **РЕЗУЛЬТАТ**, подобно тому, как это имеет место в приведенной в самом начале формулировке задачи. Хотя реальные формулировки могут и не включать явно этих слов но **ДАНО** и **РЕЗУЛЬТАТ** должны легко выводиться из записанных в формулировках утверждений.

Некоторая сложность при составлении таких формулировок может заключаться в необходимости составления их так, чтобы они соответствовали *всем возможным* случаям применения соответствующих функций. Причем формулировки эти должны быть *полными*: каждая мелочь может иметь решающее значение.

## Об аннотировании аргументов функций

Во всех приведенных здесь примерах в определениях функций типы их аргументы были аннотированы. Однако в языке Julia такая аннотация не является обязательной. То есть, можно было бы и не указывать типы аргументов функций, так же как это, например, имеет место быть в языке Python. Поэтому, если во всех приведенных примерах функций убрать аннотацию типов аргументов, то по-прежнему всё будет работать. 

Возможность аннотирования типов даёт следующие преимущества.

- Функции с одним и тем же именем, но с разными типами аргументов (и/или разным количеством аргументов) — это разные функции (в терминологии Julia — разные методы одной функции). Это то, что называется [https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BC%D0%B5%D1%82%D0%BE%D0%B4](множественной диспетчеризацией). Множественная диспетчеризация позволяет иметь специализированные вырианты (методы) функции для каждого набора типов аргументов, то есть выполнять те или иные действия, в зависимости от их типов.
- Заголовок определения функции с аннотированными типами аргументов делает более понятным их назначение (отсутствие аннотирования всегда можно компенсировать в этом смысле подробным документированием самой функции).
- Аннотирование типов аргументов предохраняет от потенциальных ошибок использования функции. Причём, что особенно ценно, такого рода ошибки могут быть обнаружены анализатором кода ещё на этапе подготовки программы. Отсутствие аннотирования аргументов функции компенсируется в этом смысле тем, что ошибки типизаци обычно (но не всегда) легко выявляются при отладке программы.

Вообще, типы бывают абстрактными и конкретными. Все типы аргументов в приведённых примерах — конкретные. Абстрактные типы предназначены исключительно для создания иерархии типов путём использования механизма наследования. 

Использование конкретных типов при аннотировании аргументов функций - не всегда правильное решение, потому что это препятствует обобщённому подходу к программированию, основанному на так называемых обобщённых функциях. Цель разработки обобщённой функции — сделать сферу её применения максимально широкой без изменения кода реализации. Однако то, в каких именно случаях, и как лучше всего аннотировать аргументы функций, и как программировать обобщённо — это предмет отдельного обсуждения, пока что мы этот, безусловно важный для проектирования, момент игнорируем.

## Функции и файлы

Хотя определения функций и могут быть сделаны непосредственно в REPL, обычно все нужные определения, решающие задачу, размещают и хранят в отдельном файле, или в нескольких файлах. Пусть в нашем случае такой файл будет иметь имя `example.jl`. Тогда, чтобы выполнить функцию `mark_kross!` из REPL нужно будет определения этой и вспомогательных для неё функций вставить в REPL с помощью include("example.jl"). Вот вся последовательность необходимых действий:

    julia> include("robot.jl")
    julia> include("example.jl")
    lulia> r=Robot(animate=true) # возможно редактирование обстановки 
    julia> mark_kross!(r)

Разумеется, после внесения каких-либо изменений в файл `example.jl` перед повторным вызовом `mark_kross!(r)` необходимо будет заново выполнить `include("example.jl")`. Причём, поскольку файл `example.jl` содержит лишь определения функций вне отдельного модуля (в языке Julia есть специальная синтаксичская конструкция — `module`, ограничивающая область видимости имён, и которая в данном случае не используется), то перезапуск REPL julia не потребуется.

## Справка по использованным синтаксическим конструкциям языка Julia

### Функции

В языке Julia определение функции может иметь следующие варианты:

    function имя_функции(список_аргументов_функции)
        тело_функции
        return кортеж_возвращаемых_зеачений
    end

или

    function имя_функции(список_аргументов_функции)
        тело_функции
    end # - в этом случае возвращается значение последнего оператора в теле функции

Слово `function` в определении может и отсутствовать:

    имя_функции(список_аргументов_функции)=выражение_определяющее_функцию

Обычно так выглядят совсем короткие определения.

Кроме того, во всех вариантах определения функции после скобок со списком параметров (который может быть и пустым) можно, при желании, указывать тип возвращаемого функцией значения. Например, в заголовке одного из определений:

    move_if_possible!(r::Robot,side::HorizonSide)::Bool

указано, что функция возвращает логическое значение.

### Последовательности

Конструкция `(HorizonSide(i) for i=0:3)` представляет собой частный случай генератора последовательности. 

То есть, если бы вместо `(HorizonSide(i) for i=0:3)` было бы `\[HorizonSide(i) for i=0:3]`, то это была бы операция «спискового включения» (как в Python), результатом которой в данном случае был бы вектор (массив) из четырёх элементов. Но в случае `(HorizonSide(i) for i=0:3)` массив не формируется, а генерируется (вычисляется) последовательность тех же значений, только не сразу, а по мере надобности. Таким образом, использование генератора вместо массива даёт экономию памяти: не нужно хранить в памяти весь массив целиком (в данном случае, правда, эта экономия не очень то и существенна, ввиду малой длины последовательности).

### Арифметический цикл

Арифметический цикл имеет вид:

    for очередное_значение in итерируемый_объект_из_которого_извлекаются_значения
       тело_цикла
    end

Примеры итерируемых объектов: массив (`Array`, `Vector`, `Matrix`), кортеж (`Tuple`), диапазон, генератор, множество (`Set`), словарь (`Dict`).

### Цикл с предусловием

Цикл с предусловием имеет вид:

    while условие_продолжения_цикла
        тело_цикла
    end

### Значение оператора цикла

Оператор цикла (любого типа) в языке Julia имеет значение `nothing` (типа `Nothing`), что означает отсутсвие значения.

### Оператор ветвления

Оператор ветвления имеет вид:

    if условие
        тело_секции_отрабатывающей_если_условие_выполнено
    else
        тело_секции_отрабатывающей_в_противном_случае
    end

Возможен также укороченный вариант:

    if условие
        тело_секции_отрабатывающей_если_условие_выполнено
    end

Самый общий вариант:

    if условие_1
        тело_секции_отрабатывающей_если_условие_1_выполнено
    elseif уловие_2
        тело_секции_отрабатывающей_если_условие_2_выполнено
    ...
    elseif условие_N
       тело_секции_отрабатывающей_если_условие_N_выполнено
     else
       тело_секции_отрабатывающей_если_ни_одно_условие_не_выполнено
     end

В любом случае значением оператора `if` будет значение последнего оператора в теле фактически исполняемой секции, или `nothing` — в случае, если ни одна из секций не была выполнена (такое возможно лишь при отсутствии секции `else`).

## Перезагрузка REPL Julia

При работе в REPL иногда возникает необходимость отменить ранее сделанные определения. Напимер, если была создана переменная `x`:

    julia> x=10000

то удалить её саму из области памяти REPL окажется невозможным. То есть, невозможно именно удалить имя, а не изменить значение. Можно лишь присвоить этой переменной значение `nothing` (тип этого значения — `Nothing`), что будет означать «отсутствие» значения.

    julia> x=nothing

(значение-то на самом деле есть, просто оно — `nothing`, поэтому и поставлены кавычки).

Если была определена функция, например,

    julia> f(x::Int)=x^2

то удалить её из области REPL тоже не получится. Но её можно будет переопределить, сохранив типы аргументов, например:

    julia> f(x::Int)=x^3

Но вот если изменить при этом тип аргумента, например:

    julia> f(x::Float64)=x^2

то окажется, что старое определение не исчезнет, а будет одновременно существовать два метода одной обобщённой (`generic`) функции (см. выше о множественной диспетчеризации).

В любом случае, чтобы совсем избавиться от сделанных ранее определений, необходима перезагрузка REPL. Она выполняется с помощью встроенной функции `exit`:
    
    julia> exit()

В среде VS Code можно, однако, открыть ещё и новый экземпляр REPL, и продолжить работу в нём, сохранив прежний экземпляр REPL (между этими экземплярами можно будет спокойно переключаться, но они будут полностью изолироваными, никакой связи между ними не будет).

## Немного о терминологии

В классических объектно-ориентированных языках программирования говорят о *классах*, имеющих *методы*. Так обстоит дело, например, в языке Python. В языке С++, однако, вместо понятия «метод» используется понятие «функция-член класса», а ещё там есть функции, дружественные классу.

В таких языках *класс* — это специальная конструкция, позволяющая определять внутреннюю структуру данных, содержащуюся в каждом создаваемом с помощью констркутора класса в памяти комьютера объекте данного класса и те операции или действия, которые будут доступны программисту при программировании действий с объектами этого класса. Указанные операции или действия оформляются в виде методов класса.

А вот в языке Julia вместо классов есть типы. У типов, как и у классов, есть конструкторы, но вместо методов у них есть функции. А методы в языке Julia, в свою очередь, есть только у функций (см. выше). При этом принято говорить, что тот или иной конкретный метод *специализирует* обобщённую (`generic`) функцию.

Обычно также в ОО-языках используется точечная нотации для вызова какого-либо метода для данного объекта. Например, команда сделать шаг в направлении `Nord` в языке Python могла бы выглядеть так: `r.move(Nord)`. Но в языке Julia точечная нотация для вызова функций, ассоциированных с данным типом, не используется. Объекты соответствующего типа могут являться лишь обычными аргументами соответствующей функции.
